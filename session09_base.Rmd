
# Settings {.sidebar}

<!-- ### Search criteria -->

###### Thank you for using the iTrack COVID App, US Edition.The App uses advanced Data Science techniques to allow you to easily identify the regions in the USA  that have the highest CVOVID-19 infection spread and acceleration (also known as Growth or Reproduction Rate, or R0). In order to do so, please choose the states where you want to search and the number of top search results  to be shown.

<!-- (removing all searches the entire country)  -->
<!-- where COVID-19 is sspreading the wors accelerating the most -->

<!-- In order to find the  -->
<!-- This App automatically searches and find the most contaminated areas in the USA on  `r format(Sys.time(), '%d %B, %Y') ` -->





```{r input daysToTrack showN}
selectInput("state", 
            "Search state(s):",
            # "Step 1: Add / Remove State (sorted by longitude):",
            multiple=T, 
            selected = c( 'New York', "Vermont", "Maine", "New Hampshire", "Pennsylvania", 
                          "Washington", "Minnesota", "Montana", "North Dakota" ,"Wisconsin", "Ohio"), 
            # choices = dtData$state %>% unique %>% sort
            # selected = (dtData$state %>% unique)[1],
            
            # choices = dtGeo[country=="US"] [order(lng)]$state %>% unique 
            choices = dtGeo[country=="US" & lng <= dtGeo[state=="Guam"]$lng & state != STR_TOTAL] [order(lng)]$state %>% unique
)

sliderInput("showN", 
            label = "Find:",
            # label = "Step 2: Select the number of search results (0 to show all):",
            # pre = "top ",
            post  = "most contaminated cities",
            min = 0, max = 100, value = 40)


# h3("Show [Daily Summary]")

checkboxInput("log10", "Use Log scale", F)

# 
# h3("Show [Trends]")


sliderInput("daysToTrack", label = "Days to track:",
            min = 7, max = 90, value=60)

checkboxInput("scale", "Keep the same scale", F)



```
<!-- This database was last updated on `r dateMax`. -->

```{r r.dt, include=FALSE}
# set my.state ----



r.dt <- reactive({
  
  my.state="New York"
  my.state=input$state 
  

  #     dt <- dtGeo [ dtData, on=c("country" , "state" , "city")]; dt
  #   dt <- dtGeo [ dtData [state %in% my.state], on=c("country" , "state" , "city")]; dt
  
  if (!is.null(my.state)) {
    # if (my.state != 'All States')
    dt <- dtGeo [ dtData [state %in% my.state], on=c("country" , "state" , "city")]; 
  } else {
    dt <- dtGeo [ dtData, on=c("country" , "state" , "city")]; 
  }
    
  dt[, region:=paste0( abbreviate(state, 2, T), ": ",  city)]
  
  dt[, region:=reorder(region, -confirmed)]
  # ifelse(input$sortby, city, reorder(city, -confirmed)), 
  
  showN = 6
  showN <- input$showN
  if ( showN > 0 )
    dt <- dt %>% covid.reduceToTopNCitiesToday(showN);dt 
  
  dt[, recovered:=NULL]
  
  if (T) {
    dt[, confirmedGrowth := round ( confirmed / shift(confirmed,1) , 3)] [ ] # aka  R0
    
    dt[, confirmedAcceleration := confirmed - shift(confirmed,1) ] [ ] # aka  R0
    dt[, confirmedPercentage:=round(confirmed/population*100,1)] []
    dt[, confirmedTotal := cumsum(confirmed)] []
    dt[, confirmedTotalPercentage := round(confirmedTotal/population*100,1)]

    dt[, deathsAcceleration := deaths - shift(deaths,1) ] [ ] # aka  R0
    dt[, deathsPercentage:=round(deaths/population*100,1)][]
    dt[, deathsTotal := cumsum(deaths)][]
    dt[, deathsTotalPercentage := round(deathsTotal/population*100,1)]
  } else {
    
    colsCases <- c("confirmed", "deaths")
    
    colsGrowth <- paste0(colsCases, "Growth")
    dt[ ,  (colsGrowth) := round ( .SD / shift(.SD, 1) , 3) , .SDcols = colsCases] [ ] 
    
    colsPercentage <- paste0(colsCases, "Percentage")
    colsTotal <- paste0(colsCases, "Total")
    colsTotalPercentage  <- paste0(colsCases, "TotalPercentage")
    

    dt[ ,  (colsPercentage) := lapply(.SD,  function(x) { round(x/population*100,1)  }   ), .SDcols = colsCases] []
    dt[ ,  (colsTotal) := cumsum(.SD), .SDcols = colsCases] []
    dt[ ,  (colsTotalPercentage) :=  lapply(.SD,  function(x) { round(x/population*100,1)  }   ), .SDcols = colsTotal] []
  }
  
  dt[, deathRate := round (deaths/confirmed*100,2)]
  dt[, deathRateAverage := round (deathsTotal/confirmedTotal*100,2)]
  
})

```



<!-- # Map -->
# Search Criteria and Map

## Column name not printed {data-width=1000}

### Map

```{r}

library(leaflet)

renderLeaflet({
  
  dtToday <- r.dt()[date==dateMax] 
  dtToday[, ratingcol:= ifelse(confirmedGrowth<1, "yellow", "red")]

  dtToday[, strMessage:= paste0(state, " - ", city, 
                                ":<br><b>Confirmed</b>",
                                "<br>  Total: ", confirmedTotal, "(", confirmedTotalPercentage, "%)",
                                "<br>  Daily: ", confirmed, "(", confirmedPercentage, "% population)", 
                                "<br> <b>Deaths</b>",
                                "<br>  Total: ", deathsTotal, "(", deathsTotalPercentage, "%)",
                                "<br>  Daily: ", deaths, "(", deathsPercentage, "% population)",
                                "<br><b>Death rate </b>", 
                                "<br>  Today: ", deathRate, ". Average: ", deathRateAverage
  )  ]
  
  leaflet::leaflet(dtToday) %>% 
    addTiles() %>%
    addCircleMarkers(~lng, ~lat, 
                     color = ~ratingcol, 
                     popup = ~strMessage,
                     label = ~paste0(city, ": ", confirmed, "(", confirmedPercentage, "%) / day. R0=", confirmedGrowth) 
    ) %>% 
    addPopups(~lng,  ~lat, 
              popup = ~paste0(city, ": ", confirmed, " / day. R0=", confirmedGrowth) 
    )  %>%
    addLegend("bottomleft",
              colors = c("yellow","red"),
              labels = c(
                "Growth (R0) < 1",
                "Growth (R0) > 1"),
              opacity = 0.7)
  
})
```



<!-- #  Situation today (`r format(Sys.time(), '%d %B, %Y')`) -->
# Daily Summary
<!-- # Dynamics today -->
<!-- # Today -->

<!-- #### Plot settings: -->
<!-- ```{r} -->
<!-- checkboxInput("log10", "Use Log scale", F) -->
<!-- ``` -->

## .... Upper Row {.tabset .tabset-fade }


### Situation today


```{r}

r.gToday <- reactive({
  dt <- r.dt()

  g <- dt[date==dateMax] %>%
    ggplot(
      # aes(x=region)
      aes(x=
            region,
            # reorder(region, get(input$sortby))
          # reorder(region, ifelse(input$ascending, 1, -1)*get(input$sortby)),
      )
    )  +
    theme_bw() +
    # facet_grid(reorder(region, region)~.) +

    coord_flip() + 
    scale_fill_distiller(palette = "Reds", direction = 1) +   #scale_fill_grey(0.3, 0.9) +

    
    geom_col(aes(y=deaths, fill=deathRate), alpha=0.99) +
    geom_point(aes(y=deaths, size=deathsTotal ), alpha=0.9, col="red") +
    geom_point(aes(y=deaths-deathsAcceleration, size=deathsTotal),  alpha=0.4, col="red") +

    geom_col(aes(y=confirmed), alpha=0.3, fill="orange") +
    geom_point(aes(y=confirmed-confirmedAcceleration, size=confirmedTotal), data = dt[date==dateMax-1], alpha=0.4, col="orange") +
        # geom_point(aes(y=confirmed, size=confirmedTotal), data = dt[date==dateMax-1], alpha=0.4, col="orange") +
    geom_point(aes(y=confirmed, size=confirmedTotal ), alpha=0.99, col="orange") +



    geom_segment( aes( xend=region,
                       yend=confirmed, y=confirmed-confirmedAcceleration      ),
                  size = 1, col="black",
                  arrow = arrow(length = unit(0.1, "cm"))
    ) +

    guides(col="none") +

    theme(legend.position = "bottom") +
    labs(
      title= paste0("Number of infected and deaths on ", dateMax),
      # # title= paste0("Increase in the number of infected and deaths per day on ", input$dateToday),
      # # title= paste0("Speed and acceleration of pandemic on ", format(Sys.time(), "%d %B, %Y") ),
      # # title= paste0("Pandemic dynamics on ", input$dateToday), # dateMax),
      #
      # subtitle=
      #   # r.subtitle(),
      #   paste0("Top ", min (dt %>% nrow, input$showN), " regions ",
      #          "in ", my.paste(input$region, ", "),
      #          " (sorted by '", input$sortby, "')."
      #          # , ". States/Provinces: ", my.paste(input$state, ", ")
      #   ),

      size="Total number of cases",
      fill="Mortality rate ",
      # y="Infected (orange) and deaths (red) per day. \nChange since yesterday is marked by arrow.",
      y=NULL,
      x=NULL

      # caption=caption.covid
    )


  if (input$log10 ) {
    g <- g + scale_y_log10()
  }

  g
})

renderPlot( {
  print( r.gToday() )
})

```

> The plot shows the top results, sorted by the growth rate. Change in the number of infected cases since yesterday is marked by arrow.



###  Searchable graph
<!-- ###Explore search results -->

```{r}

renderPlotly( {
  ggplotly(r.gToday())
})


```

> The plot shows the top results, sorted by the selected criteria. Change in the number of infected cases since yesterday is marked by arrow.



# Trends

## This caption is not printed {.tabset .tabset-fade } 

### Pandemic spread analysis
<!-- ### Dynamics over time -->

```{r fig.width=12, fig.height=9, fig.align='center'}


r.gTrend <- reactive({
  g <- r.dt() [ date > dateMax - input$daysToTrack] %>% 

    ggplot() + 

    facet_wrap( . ~  region,
                scales=ifelse(input$scale, "fixed", "free")) +  
    geom_line(aes(date, confirmed), col="orange") +
    labs(
      title= paste0("Infected per day"),
      subtitle=paste0("State: ", input$state, ". Date: ", dateMax, " (Cities are sorted by the number of infected)"),  
      caption=paste0( 
        "Data source: Johns Hopkins University U.S. Coronavirus database\n",
        "Generated by R Ottawa"
      )
    )
  
  if (input$log10 ) {
    g <- g + scale_y_log10()
  }
  
  
})

renderPlot( {
  print( r.gTrend() )
})

```

### Interactive plot

```{r}
renderPlotly( {
  ggplotly( r.gTrend() )
})

```

# Detailed Results
<!-- # Table -->

## Column name not printed 


### Today  {data-height=1000}

```{r}
DT::renderDataTable({
  
  r.dt() [date==dateMax]%>% 
    DT::datatable(
      filter ="top",
      options = list(
        scrollY = TRUE,
        scrollX = TRUE)
    )
})
```




# Info {data-icon="fa-info-circle"}

<!-- ## Column -->
## Column {.tabset .tabset-fade }

### About App

#### Technical information



*Name*: COVID-19 Tracker  (US - Light Version)    
*Type*: Web Application. Compatible with mobile devices.  
*License*:  [CC BY-NC](https://creativecommons.org/licenses/by-nc/4.0/legalcode).   
*Developer*: [Dmitry Gorodnichy](https://www.linkedin.com/in/dmitry-gorodnichy/)  and  [R Ottawa community](https://ivi-m.github.io/R-Ottawa/). 

*URL*: https://itrack.shinyapps.io/covid/us.Rmd    
<!-- *Code*: https://ivi-m.github.io/R-Ottawa/101.html -->
*Last updated*: 5 June 2020
*Version*: 0.0.8-us

*Questions/Comments*: [dg@ivim.ca](email:dg@ivim.ca)
<!-- *Contact*: [dg@ivim.ca](email:dg@ivim.ca) -->



<!-- This App is developed as part of the *"Lunch and Learn R101"* sessions, organized by Dmitry Gorodnichy within the  [R Ottawa community](https://ivi-m.github.io/R-Ottawa).  -->
<!-- The sessions are free and open to public. They are also recorded and can be watched at YouTube.  --> 
<!-- See  [R Ottawa - R101](https://ivi-m.github.io/R-Ottawa/101.html) portal for the code and explanations. -->
<!-- For other countries and more functionalities, visit [https://itrack.shinyapps.io/covid](https://itrack.shinyapps.io/covid). -->


This App is developed as part of the *"Lunch and Learn: R101"* sessions, organized by Dmitry Gorodnichy within the  [R Ottawa community](https://ivi-m.github.io/R-Ottawa). 

For the code, explanations and other versions of this App that we developped, 
visit  [R Ottawa - R101](https://ivi-m.github.io/R-Ottawa/101.html) portal 

For other countries and more functionalities, visit [https://itrack.shinyapps.io/covid](https://itrack.shinyapps.io/covid).


<!-- title: "COVID-19 in US"     -->
<!-- subtitle: "Situational Analysis Report"     -->
<!-- author: "Dmitry Gorodnichy"    -->
<!-- <!-- date: "Last updated: `r format (Sys.time(), '%d %B, %Y')`"    --> 
<!-- date: "Last updated: `3 June 2020`"    -->




#### Disclaimer 

This work is not to be associated with any  work done by the Government of Canada. The authors are not liable for any errors that might be present in  data or data interpretation. For all official information related to Covid in Canada please visit the official [Coronavirus disease (COVID-19) site](https://www.canada.ca/en/public-health/services/diseases/coronavirus-disease-covid-19.html?utm_campaign=not-applicable&utm_medium=vanity-url&utm_source=canada-ca_coronavirus).



#### Acknowledgements

The App is developed using R in RStudio. 
The following R libraries are used:    

- Data management: data.table, dtplyr,  stringr, readxl, lubridate, magrittr.   
- Data visualization: ggplot2, plotly, leaflet, DT.  
<!-- - Machine learning: caret, GMDH.   (TBA) -->
- Publishing: shiny, rsconnect,  knitr, rmarkdown, flexdashboard.   


### Data sources

<!-- This report is generated automatically.  -->



The COVID-19 data is taken from:  

<!-- - [Johns Hopkins University Global Coronavirus database](https://coronavirus.jhu.edu/map.html),  -->
<!-- which is available at this [GitHub repository](https://github.com/RamiKrispin/coronavirus-csv)  -->

- [Johns Hopkins University U.S. Coronavirus database](https://coronavirus.jhu.edu/us-map), 
which is available at this [GitHub   repository](https://github.com/CSSEGISandData/COVID-19) 

<!-- - [University of Toronto Coronavirus database](https://art-bd.shinyapps.io/covid19canada/), -->
<!-- which is  curated by the [COVID-19 Canada Open Data Working Group](https://github.com/ishaberry/Covid19Canada) -->


This database was last updated on `r dateMax`.
To 

